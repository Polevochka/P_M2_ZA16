// модуль с процедурами обработки матриц
unit Unit2;

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils;

type
  // создадим тип для матрицы
  // нужен для передачи матрицы в функции обработки
  // кстати т.к. он в области interface и этот модуль мы подключаем в unit1
  // то этот тип можо будет использовать в unit1
  TMatrix = array[1..20, 1..20] of integer;

// прототипы функций которые ДОЛЖНЫ быть ВЫДНЫ в ДРУГИХ модулях(unit1)
procedure FillMatrix(var M: TMatrix; rows: integer; cols: integer);
procedure MoveUp(var M:TMatrix; rows: integer; cols: integer);
procedure MoveDown(var M:TMatrix; rows: integer; cols: integer);
// Интересно будет отметить, что функцию PosIndexMaxInCol
// здесь не надо указывать, тк она нигде кроме как внутри функций
// MoveUp и MoveDown не используется

{для работы защиты расскоментируйте}
//procedure MoveRight(var M:TMatrix; rows: integer; cols: integer);
//procedure MoveLeft(var M:TMatrix; rows: integer; cols: integer);

implementation

{Процедура заполнения матрицы рандомными числами}
//'var M' - т.к. меняем элементы матрицы
//   rows - число строк матрицы
//   cols - число столбцов матрицы
procedure FillMatrix(var M: TMatrix; rows: integer; cols: integer);
var i, j: integer;
begin
  randomize;   // для генератора случайных чисел - более случайное число
   for i:=1 to rows do
       for j:=1 to cols do
           M[i,j] := random(100); // рандомное число на отрезке [0;99]
end;

{Функция поиска максимального элемента в СТОЛБЦЕ}
// Возвращает номер строки, в которой находится максимальный элемент из столбца 'c'
//   M - сама матрица в которой ведётся поиск (заметьте без var, тк ничего не меняем здесь)
//   rows - число строк в матрице
//   с - номер столбца в котором ищем максимальный элемент
// Здесь также важно отметить, что ЧИСЛО СТОЛБЦОВ передавать не нужно,
// т.к. поиск ведётся ТОЛЬКО в ОДНОМ столбце с номером c
function PosIndexMaxInCol(M:TMatrix; rows: integer; c: integer): integer;
var i_max: integer; // индекс максимального элемента в столбце
    i: integer; // для перебора строк
begin
  // Сначала предполагаем, что максимальный элемент находиться в 1-ой строчке
  // Дальше если найдём элемент побольше, то просто поменяем значение
  i_max := 1;

  // Обходим другие строки и ищем элементы побольше,
  // ПРИЧОМ начиная со 2-ой, т.к. первую строку УЖЕ 'обработали'
  for i:=2 to rows do
    if M[i_max, c] < M[i, c] then i_max := i;

  // найденное значение присваиваем имени функции - это то
  // что оно вернёт после своей работы
  PosIndexMaxInCol := i_max;

end;

{Процедура перемещает максимальные элементы в СТОЛБЦАХ НАВЕРХ}
procedure MoveUp(var M:TMatrix; rows: integer; cols: integer);
var i_max: integer; // индекс максимального элемента для j - го столбца
    // вспомогательная переменная для перестановки элементов в матрице
    temp: integer;
    i, j: integer;
begin
  // Сначала обходим все столбцы матрицы
  for j:=1 to cols do
  begin
    // находим индекс максимального элемента в j-ом столбце
    i_max := PosIndexMaxInCol(M, rows, j);

    // передвигаем элемент с этим индексом наверх
    // то есть на ПЕРВУЮ строку матрицы

    // сначала сохраним значение в буферную - вспомогательную переменную
    temp := M[i_max, j];

    // Потом смещаем все элементы выше его вниз на одну позицию(затирая его)
    // до двух, т.к. если i=1 то получится M[i-1, j] = M[0, j] - НЕТ такого элемента
    for i := i_max downto 2 do
        M[i, j]:= M[i-1, j];

    {
        То есть
        было :    1            стало:    1
                  2                      1
                  3                      2
                  max                    3
                  4                      4
                  5                      5
    }

    // нетрудно заметить, что теперь первый  и второй элементы столбца дублируются
    // теперь как раз мы можем записать на первое место наш максимальный элемент,
    // значение которого было сохранено в temp
    M[1,j] := temp;

    // задача для одного столбца выполнена, переходим к другим
  end;
end;

{Процедура перемещает максимальные элементы в СТОЛБЦАХ ВНИЗ}
procedure MoveDown(var M:TMatrix; rows: integer; cols: integer);
var i_max: integer; // индекс максимального элемента для j - го столбца
    // вспомогательная переменная для перестановки элементов в матрице
    temp: integer;
    i, j: integer;
begin
  // Сначала обходим все столбцы матрицы
  for j:=1 to cols do
  begin
    // находим индекс максимального элемента в j-ом столбце
    i_max := PosIndexMaxInCol(M, rows, j);

    // передвигаем элемент с этим индексом вниз
    // то есть на ПОСЛЕДНЮЮ строку матрицы с индексом rows

    // сначала сохраним значение в буферную - вспомогательную переменную
    temp := M[i_max, j];

    // Потом смещаем все элементы ниже максимума вверх на одну позицию(затирая его)
    // до rows-1, т.к. если i=rows то получится M[i+1, j] = M[rows+1, j] - НЕТ такого элемента
    for i := i_max to rows-1 do
        M[i, j]:= M[i+1, j];

    {
        То есть
        было :    1            стало:    1
                  2                      2
                  max                    3
                  3                      4
                  4                      5
                  5                      5
    }

    // нетрудно заметить, что теперь два последних элемента столбца дублируются
    // теперь как раз мы можем записать на последнее место наш максимальный элемент,
    // значение которого было сохранено в temp
    M[rows,j] := temp;

    // задача для одного столбца выполнена, переходим к другим
  end;
end;

// ---------------------------------------------------------------------------------------------

{ЗАЩИТА}

// Преподаватель может попросить изменить программу так,
// чтобы находили максимумы не в столбцах а в строках и
// перемещать эти элементы не вверх вниз, а влево вправо
// Делаем то же самое, что и выше только для строк

// НЕ ЗАБУДЕМ, ЧТО прототипы процедур MoveLeft и MoveRight
// Должны быть в секции interface

{Функция поиска максимального элемента в СТРОКЕ}
// Возвращает номер строки, в которой находится максимальный элемент из столбца 'c'
//   M - сама матрица в которой ведётся поиск (заметьте без var, тк ничего не меняем здесь)
//   cols - число столбцов в матрице
//   r - номер строки в которой ищем максимальный элемент
// Здесь также важно отметить, что ЧИСЛО СТРОК передавать не нужно,
// т.к. поиск ведётся ТОЛЬКО в ОДНОЙ строке с номером 'r'
function PosIndexMaxInRow(M:TMatrix; cols: integer; r: integer): integer;
var j_max: integer; // индекс максимального элемента в строке
    j: integer; // для перебора столбцов
begin
  // Сначала предполагаем, что максимальный элемент находиться в 1-ом столбце
  // Дальше если найдём элемент побольше, то просто поменяем значение
  j_max := 1;

  // Обходим другие столбцы и ищем элементы побольше,
  // ПРИЧОМ начиная со 2-ого, т.к. первый столбец УЖЕ 'обработали'
  for j:=2 to cols do
    if M[r, j_max] < M[r, j] then j_max := j;

  // найденное значение присваиваем имени функции - это то
  // что оно вернёт после своей работы
  PosIndexMaxInRow := j_max;

end;


{Процедура перемещает максимальные элементы в СТРОКАХ ВЛЕВО}
procedure MoveLeft(var M:TMatrix; rows: integer; cols: integer);
var j_max: integer; // индекс максимального элемента для i - ой строчки
    // вспомогательная переменная для перестановки элементов в матрице
    temp: integer;
    i, j: integer;
begin
  // Сначала обходим все строки матрицы
  for i:=1 to rows do
  begin
    // находим индекс максимального элемента в i-ой строке
    j_max := PosIndexMaxInRow(M, cols, i);

    // передвигаем элемент с этим индексом ВЛЕВО
    // то есть на ПЕРОВОЕ место (j=1) для i-ой строки

    // сначала сохраним значение в буферную - вспомогательную переменную
    temp := M[i, j_max];

    // Потом смещаем все элементы Левее максимума вправо на одну позицию(затирая его)
    // до 2, т.к. если j=1 то получится M[i, j-1] = M[i, 0] - НЕТ такого элемента
    for j := j_max downto 2  do
        M[i, j]:= M[i, j-1];
    {
        То есть
        Было   : 1 2 3 max 4 5
        Стало  : 1 1 2 3 4 5
    }

    // нетрудно заметить, что теперь два первых элемента i-ой строки дублируются
    // теперь как раз мы можем записать на ПЕРВОЕ место наш максимальный элемент,
    // значение которого было сохранено в temp
    M[i,1] := temp;
    // Теперь : max 1 2 3 4 5

    // задача для одной строки выполнена, переходим к другим
  end;
end;


{Процедура перемещает максимальные элементы в СТРОКАХ ВПРАВО}
procedure MoveRight(var M:TMatrix; rows: integer; cols: integer);
var j_max: integer; // индекс максимального элемента для i - ой строчки
    // вспомогательная переменная для перестановки элементов в матрице
    temp: integer;
    i, j: integer;
begin
  // Сначала обходим все строки матрицы
  for i:=1 to rows do
  begin
    // находим индекс максимального элемента в i-ой строке
    j_max := PosIndexMaxInRow(M, cols, i);

    // передвигаем элемент с этим индексом ВПРАВО
    // то есть на ПОСЛЕДНЕЕ место (j=cols) для i-ой строки

    // сначала сохраним значение в буферную - вспомогательную переменную
    temp := M[i, j_max];

    // Потом смещаем все элементы Правее максимума влево на одну позицию(затирая его)
    // до cols-1, т.к. если j=cols то получится M[i, j+1] = M[i, cols+1] - НЕТ такого элемента
    for j := j_max to cols-1  do
        M[i, j]:= M[i, j+1];
    {
        То есть
        Было   : 1 2 3 max 4 5
        Стало  : 1 2 3 4 5 5
    }

    // нетрудно заметить, что теперь два послдених элемента i-ой строки дублируются
    // теперь как раз мы можем записать на ПОСЛЕДНЕЕ место наш максимальный элемент,
    // значение которого было сохранено в temp
    M[i,cols] := temp;
    // Теперь : 1 2 3 4 5 max

    // задача для одной строки выполнена, переходим к другим
  end;
end;


end.
